#include <stdlib.h>
#include <time.h>
#include <math.h>
#include <string.h>
#include <stdio.h>
#include "mmm.h"

/**
 * Allocate and initialize the matrices on the heap. Populate
 * the input matrices with random integers from 0 to 99
 */

//  typedef struct thread_args {
// 	int tid; //thread id
// 	int row_start;
// 	int row_end;
//  } thread_args;
void mmm_init() {
	matrix1 = (double**) malloc (size *sizeof(double*));
	matrix2 = (double**) malloc (size *sizeof(double*));
	matrix3 = (double**) malloc (size *sizeof(double*));
	matrix4 = (double**) malloc (size *sizeof(double*));
	for(int i = 0; i < size; i++){
		matrix1[i] = (double*) malloc(sizeof(double) * (size));
		matrix2[i] = (double*) malloc(sizeof(double) * (size));
		matrix3[i] = (double*) malloc(sizeof(double) * (size));
		matrix4[i] = (double*) malloc(sizeof(double) * (size));
	}
	for(int i = 0; i < size; i++){
		for(int j = 0; j < size; j++){
			matrix1[i][j] = rand() % 100;
			matrix2[i][j] = rand() % 100;
		}
	}
}

/**
 * Reset a given matrix to zeroes
 * @param matrix pointer to a 2D array
 */
void mmm_reset(double **matrix) {
	for(int i = 0; i < size; i++){
		for(int j = 0; j < size; j++){
			matrix[i][j] = 0;
		}
	}
}

/**
 * Free up memory allocated to all matrices
 */
void mmm_freeup() {
	// for (int i = 0; i < size; i++) {	
    // 	free(matrix1[i]);
	// 	free(matrix2[i]);
	// 	free(matrix3[i]);
	// 	free(matrix4[i]);

	// 	matrix1[i] = NULL;
	// 	matrix2[i] = NULL;
	// 	matrix3[i] = NULL;
	// 	matrix4[i] = NULL;
	// }

 
}

/**
 * Sequential MMM
 */
void mmm_seq() {
	for(int i = 0; i < size; i++){
		for(int j = 0; j < size; j++){
			for(int k = 0; k < size; k++){
				matrix3[i][j] += matrix1[i][k] * matrix2[k][j];
			}
		}
	}
}

/**
 * Parallel MMM
 */
void *mmm_par(void *args) {
	thread_args *params = (thread_args*)args;
	for(int i = params->row_start; i < params->row_end; i++){
		for(int j = 0; j < size; j++){
			for(int k = 0; k < size; k++){
				matrix4[i][j] += matrix1[i][k] * matrix2[k][j];
			}
		}
	}
	return NULL;
}
/**
 * Verifies the correctness between the matrices generated by
 * the sequential run and the parallel run.
 *
 * @return the largest error between two corresponding elements
 * in the result matrices
 */
double mmm_verify() {
	double maxDifference = 0;
	for(int i = 0; i < size; i++){
		for(int j = 0; j < size; j++){
			double errors = matrix3[i][j] - matrix4[i][j];
			if(errors > maxDifference){
				maxDifference = errors; //checking to see the maxDifference.
			}
			
		}
	}


	return maxDifference;
}
